<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"client-api.js.html":{"id":"client-api.js.html","title":"Source: client-api.js","body":" Mailvelope API Classes EditorGeneratorKeyBackupPopupKeyringMailvelopeOpenPGPEncryptedFormRestoreBackup Tutorials Readme Global Global Source: client-api.js /** * The MIT License (MIT) * * Copyright (c) 2014-2019 Mailvelope GmbH * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. */ /** * @type {Mailvelope} */ class Mailvelope { /** * Gives access to the mailvelope extension version * @returns {Promise.&lt;String, Error&gt;} */ getVersion() { return send('get-version'); } /** * Retrieves the Keyring for the given identifier * @param {String} identifier - the identifier of the keyring, if empty the main keyring is returned * @returns {Promise.&lt;Keyring, Error&gt;} * @throws {Error} error.code = 'NO_KEYRING_FOR_ID' */ getKeyring(identifier) { return send('get-keyring', {identifier}).then(options =&gt; new Keyring(identifier, options)); } /** * Creates a Keyring for the given identifier * @param {String} identifier - the identifier of the new keyring * @returns {Promise.&lt;Keyring, Error&gt;} * @throws {Error} error.code = 'KEYRING_ALREADY_EXISTS' * @example * mailvelope.createKeyring('Account-ID-4711').then(function(keyring) { * // continue to display the settings container and start the setup wizard * mailvelope.createSettingsContainer('#mailvelope-settings', keyring); * }); */ createKeyring(identifier) { return send('create-keyring', {identifier}).then(options =&gt; new Keyring(identifier, options)); } /** * Ascii Armored PGP Text Block * @typedef {String} AsciiArmored */ /** * CSS Selector String * @typedef {String} CssSelector */ /** * @typedef {Object} DisplayContainerOptions * @property {String} senderAddress - email address of sender, used to indentify key for signature verification */ /** * @typedef {Object} DisplayContainer * @property {Error} error - Error object with code and message attribute * error.code = 'DECRYPT_ERROR' - generic decrypt error * error.code = 'ARMOR_PARSE_ERROR' - error while parsing the armored message * error.code = 'PWD_DIALOG_CANCEL' - user canceled password dialog * error.code = 'NO_KEY_FOUND' - no private key found to decrypt this message */ /** * Creates an iframe to display the decrypted content of the encrypted mail. * The iframe will be injected into the container identified by selector. * @param {CssSelector} selector - target container * @param {AsciiArmored} armored - the encrypted mail to display * @param {Keyring} [keyring] - the keyring to use for this operation * @param {DisplayContainerOptions} options * @returns {Promise.&lt;DisplayContainer, Error&gt;} */ createDisplayContainer(selector, armored, keyring, options) { try { checkTypeKeyring(keyring); } catch (e) { return Promise.reject(e); } return send('display-container', {selector, armored, identifier: keyring &amp;&amp; keyring.identifier, options}).then(display =&gt; { if (display &amp;&amp; display.error) { display.error = mapError(display.error); } return display; }); } /** * @typedef {Object} EditorContainerOptions * @property {number} quota - mail content (text + attachments) limit in kilobytes (default: 20480) * @property {boolean} signMsg - if true then the mail will be signed (default: false) * @property {AsciiArmored} armoredDraft - a PGP message, signed and encrypted with the default key of the user, will be used to restore a draft in the editor * The armoredDraft parameter can't be combined with the parameters: predefinedText, quotedMail... parameters, keepAttachments * @property {String} predefinedText - text that will be added to the editor * @property {AsciiArmored} quotedMail - mail that should be quoted * @property {boolean} quotedMailIndent - if true the quoted mail will be indented (default: true) * @property {String} quotedMailHeader - header to be added before the quoted mail * @property {boolean} keepAttachments - add attachments of quotedMail to editor (default: false) */ /** * Creates an iframe with an editor for a new encrypted mail. * The iframe will be injected into the container identified by selector. * @param {CssSelector} selector - target container * @param {Keyring} [keyring] - the keyring to use for this operation * @param {EditorContainerOptions} options * @returns {Promise.&lt;Editor, Error&gt;} * @throws {Error} error.code = 'WRONG_ARMORED_TYPE' - parameters of type AsciiArmored do not have the correct armor type &lt;br&gt; error.code = 'INVALID_OPTIONS' - invalid combination of options parameter * @example * mailvelope.createEditorContainer('#editor-element', keyring).then(function(editor) { * // register event handler for mail client send button * $('#mailer-send').click(function() { * // encrypt current content of editor for array of recipients * editor.encrypt(['info@mailvelope.com', 'abc@web.de']).then(function(armored) { * console.log('encrypted message', armored); * }); * }); * }); */ createEditorContainer(selector, keyring, options) { try { checkTypeKeyring(keyring); } catch (e) { return Promise.reject(e); } return send('editor-container', {selector, identifier: keyring &amp;&amp; keyring.identifier, options}).then(editorId =&gt; new Editor(editorId)); } /** * @typedef {Object} SettingsContainerOptions * @property {String} email - the email address of the current user * @property {String} fullName - the full name of the current user */ /** * Creates an iframe to display the keyring settings. * The iframe will be injected into the container identified by selector. * @param {CssSelector} selector - target container * @param {Keyring} [keyring] - the keyring to use for the setup * @param {SettingsContainerOptions} options * @returns {Promise.&lt;undefined, Error&gt;} */ createSettingsContainer(selector, keyring, options) { try { checkTypeKeyring(keyring); } catch (e) { return Promise.reject(e); } return send('settings-container', {selector, identifier: keyring &amp;&amp; keyring.identifier, options}); } /** * Creates an iframe to display an encrypted form * The iframe will be injected into the container identified by selector. * @param @param {String} selector - the id of target container * @param @param {String} formHtml - the form definition * @param @param {String} signature - the OpenPGP signature * @returns {Promise.&lt;Object, Error&gt;} an object that includes armoredData * @throws {Error} error.code = 'INVALID_FORM' the form definition is not valid */ createEncryptedFormContainer(selector, formHtml, signature) { return send('encrypted-form-container', {selector, formHtml, signature}); } } // connection to content script is alive let connected = true; let syncHandler = null; function checkTypeKeyring(keyring) { if (keyring &amp;&amp; !(keyring instanceof Keyring)) { const error = new Error('Type mismatch: keyring should be instance of Keyring.'); error.code = 'TYPE_MISMATCH'; throw error; } } /** * Not accessible, instance can be obtained using {@link Mailvelope#getKeyring} * or {@link Mailvelope#createKeyring}. * @param {String} identifier - the keyring identifier * @param {object} options - the options * @property {number} logoRev - revision number of the keyring logo, initial value: 0 */ class Keyring { constructor(identifier, options) { this.identifier = identifier; this.logoRev = options.revision || 0; } /** * @typedef {Object} LookupResult * @property {String} fingerprint - Fingerprint of the key * @property {Date} lastModified - last time the key was modified * @property {String} source - Source the key was found at &lt;br&gt; * Currently available: &lt;br&gt; * * 'LOC' - local key ring &lt;br&gt; * * 'WKD' - web key directory &lt;br&gt; * * 'MKS' - mailvelope key server &lt;br&gt; * * 'AC' - autocrypt * @property {Date} [lastSeen] - last time the key was seen &lt;br&gt; * (not set for local keys) * @property {String} [armored] - Armored key that can be imported &lt;br&gt; * (not set for local keys) */ /** * Checks for valid key in the keyring for provided email addresses * If none is found also checks in other sources (see LookupResult). * @param {Array} recipients - list of email addresses for key lookup * @returns {Promise.&lt;Object, Error&gt;} The object maps email addresses to: &lt;br&gt; * false: no valid key &lt;br&gt; * {keys: [LookupResult]}: valid keys * * @example * keyring.validKeyForAddress(['abc@web.de', 'info@mailvelope.com']).then(function(result) { * console.log(result); * // { * // 'abc@web.de': false, * // 'info@mailvelope.com': { * // keys: [ * // { * // fingerprint: 'f37377c39898d05ffd39157a98bbec557ce08def', * // lastModified: Tue May 19 2015 10:36:53 GMT+0200 (CEST), * // source: 'LOC' * // } * // ] * // } * // } * }); */ validKeyForAddress(recipients) { return send('query-valid-key', {identifier: this.identifier, recipients}).then(keyMap =&gt; { for (const address in keyMap) { if (keyMap[address]) { keyMap[address].keys.forEach(key =&gt; { key.lastModified = new Date(key.lastModified); }); } } return keyMap; }); } /** * Exports the public key as an ascii armored string. * Only keys belonging to the user (corresponding private key exists) can be exported. * @param {String} emailAddr - email address to identify the public+private key * @returns {Promise.&lt;AsciiArmored, Error&gt;} * @throws {Error} error.code = 'NO_KEY_FOR_ADDRESS' * @example * keyring.exportOwnPublicKey('abc@web.de').then(function(armoredPublicKey) { * console.log('exportOwnPublicKey', armoredPublicKey); * // prints: \"-----BEGIN PGP PUBLIC KEY BLOCK...\" * }); */ exportOwnPublicKey(emailAddr) { return send('export-own-pub-key', {identifier: this.identifier, emailAddr}); } /** * @typedef {Object} additionalMailHeaders * @property {String} autocrypt - the Autocrypt header that should be &lt;br&gt; * added to the outgoing mail&lt;br&gt; */ /** * @typedef {Object} outgoingMailHeaders * @property {String} from - the From header */ /** * Returns headers that should be added to an outgoing email. * So far this is only the `autocrypt` header. * @param {outgoingMailHeaders} headers - headers of the outgoing mail. &lt;br&gt; * In particular `from` to select the key * @returns {Promise.&lt;additionalMailHeaders, Error&gt;} * @throws {Error} error.code = 'NO_KEY_FOR_ADDRESS' * @example * keyring.additionalHeadersForOutgoingEmail(from: 'abc@web.de').then(function(additional) { * console.log('additionalHeadersForOutgoingEmail', additional); * // logs: {autocrypt: \"addr=abc@web.de; prefer-encrypt=mutual; keydata=...\"} * }); */ additionalHeadersForOutgoingEmail(headers) { return send('additional-headers-for-outgoing', {identifier: this.identifier, headers}); } /** * Asks the user if they want to import the public key. * @param {AsciiArmored} armored - public key to import * @returns {Promise.&lt;String, Error&gt;} 'IMPORTED' - key has been imported &lt;br&gt; 'UPDATED' - key already in keyring, new key merged with existing key &lt;br&gt; 'INVALIDATED' - key has been updated, new status of key is 'invalid' (e.g. revoked) &lt;br&gt; 'REJECTED' - key import rejected by user * @throws {Error} error.code = 'IMPORT_ERROR' &lt;br&gt; error.code = 'WRONG_ARMORED_TYPE' */ importPublicKey(armored) { return send('import-pub-key', {identifier: this.identifier, armored}); } /** * @typedef {Object} AutocryptMailHeaders * @property {String} autocrypt - the Autocrypt header to process * @property {String} from - the From header * @property {String} date - the Date header */ /** * Process Autocrypt header from message being read. * @param {AutocryptMailHeaders} headers - the relevant mail headers * @returns {Promise.&lt;undefined, Error&gt;} * @throws {Error} error.code = 'INVALID_HEADER' &lt;br&gt; error.code = 'STORAGE_ERROR' */ processAutocryptHeader(headers) { return send('process-autocrypt-header', {identifier: this.identifier, headers}); } /** * Set logo for keyring. The image is persisted in Mailvelope with a revision number, * therefore the method is only required after new keyring generation or if logo and revision number changes. * @param {String} dataURL - data-URL representing the logo, max. file size: ~10KB, max. image size: 192x96px, content-type: image/png * @param {number} revision - revision number * @returns {Promise.&lt;undefined, Error&gt;} * @throws {Error} error.code = 'LOGO_INVALID' &lt;br&gt; * error.code = 'REVISION_INVALID' * @example * keyring.setLogo('data:image/png;base64,iVBORS==', 3).then(function() { * // keyring.logoRev == 3 * }).catch(function(error) { * // logo update failed * }); * */ setLogo(dataURL, revision) { return send('set-logo', {identifier: this.identifier, dataURL, revision}).then(() =&gt; { this.logoRev = revision; }); } /** * @typedef {Object} UserId * @property {String} email - the email address of the current user * @property {String} fullName - the full name of the current user */ /** * @typedef {Object} KeyGenContainerOptions * @property {Array.&lt;UserId&gt;} userIds - array of user IDs. The first entry in the array is set as the primary user ID. * @property {number} keySize - key size in bit, optional, default: 2048, valid values: 2048, 4096. */ /** * Creates an iframe to display the key generation container. * The iframe will be injected into the container identified by selector. * @param {CssSelector} selector - target container * @param {KeyGenContainerOptions} options * @returns {Promise.&lt;Generator, Error&gt;} * @throws {Error} error.code = 'INPUT_NOT_VALID' */ createKeyGenContainer(selector, options) { return send('key-gen-container', {selector, identifier: this.identifier, options}).then(generatorId =&gt; new Generator(generatorId)); } /** * @typedef {Object} KeyBackupContainerOptions * @param {Boolean} initialSetup (default: true) */ /** * Creates an iframe to initiate the key backup process. * @param {CssSelector} selector - target container * @param {KeyBackupContainerOptions} options * @returns {Promise.&lt;KeyBackupPopup, Error&gt;} */ createKeyBackupContainer(selector, options) { return send('key-backup-container', {selector, identifier: this.identifier, options}).then(popupId =&gt; new KeyBackupPopup(popupId)); } /** * @typedef {Object} PrivateKeyContainerOptions * @property {boolean} restorePassword (default: false) */ /** * Creates an iframe to restore the backup. * @param {CssSelector} selector - target container * @param {PrivateKeyContainerOptions} options * @returns {Promise.&lt;undefined, Error&gt;} */ restoreBackupContainer(selector, options) { return send('restore-backup-container', {selector, identifier: this.identifier, options}).then(restoreId =&gt; new RestoreBackup(restoreId)); } /** * Check if keyring contains valid private key with given fingerprint * @param {String|{fingerprint: String, email: String}} fingerprint or Object with fingerprint or email property * @returns {Promise.&lt;boolean, Error&gt;} */ hasPrivateKey(query = {}) { const fingerprint = typeof query === 'string' ? query : query.fingerprint; const {email} = query; return send('has-private-key', {identifier: this.identifier, fingerprint, email}).then(result =&gt; result); } /** * @typedef {Object} UploadSyncReply * @property {String} eTag - entity tag for the uploaded encrypted keyring */ /** * @typedef {Function} UploadSyncHandler * @param {Object} uploadObj - object with upload data * @param {String} uploadObj.eTag - entity tag for the uploaded encrypted keyring, or null if initial upload * @param {AsciiArmored} uploadObj.keyringMsg - encrypted keyring as PGP armored message * @returns {Promise.&lt;UploadSyncReply, Error&gt;} - if version on server has different eTag, then the promise is rejected * if server is initial and uploadObj.eTag is not null, then the promise is rejected */ /** * @typedef {Object} DownloadSyncReply * @property {AsciiArmored} keyringMsg - encrypted keyring as PGP armored message, or null if no newer version available * @property {String} eTag - entity tag for the current encrypted keyring message, or null if server is intial */ /** * @typedef {Function} DownloadSyncHandler * @param {Object} downloadObj - meta info for download * @param {String} downloadObj.eTag - entity tag for the current local keyring, or null if no local eTag * @returns {Promise.&lt;DownloadSyncReply, Error&gt;} - if version on server has same eTag, then keyringMsg property of reply is empty, but eTag in reply has to be set * if server is initial and downloadObj.eTag is not null, then the promise is resolved with empty eTag */ /** * @typedef {Object} BackupSyncPacket * @property {AsciiArmored} backup - encrypted key backup as PGP armored message */ /** * @typedef {Function} BackupSyncHandler * @param {BackupSyncPacket} - object with backup data * @returns {Promise.&lt;undefined, Error&gt;} */ /** * @typedef {Function} RestoreSyncHandler * @returns {Promise.&lt;BackupSyncPacket, Error&gt;} */ /** * @typedef {Object} SyncHandlerObject * @property {UploadSyncHandler} uploadSync - function called by Mailvelope to upload the keyring (public keys), the message is encrypted with the default private key * @property {DownloadSyncHandler} downloadSync - function called by Mailvelope to download the encrypted keyring (public keys) * @property {BackupSyncHandler} backup - function called by Mailvelope to upload a symmetrically encrypted private key backup * @property {RestoreSyncHandler} restore - function called by Mailvelope to restore a private key backup */ /** * Add various functions for keyring synchronization * @param {SyncHandlerObject} syncHandlerObj * @returns {Promise.&lt;undefined, Error&gt;} */ addSyncHandler(syncHandlerObj) { if (typeof syncHandlerObj.uploadSync !== typeof syncHandlerObj.downloadSync) { return Promise.reject(new Error('uploadSync and downloadSync Handler cannot be set exclusively.')); } return send('add-sync-handler', {identifier: this.identifier}).then(syncHandlerId =&gt; { if (syncHandler) { syncHandler.update(syncHandlerObj); } else { syncHandler = new SyncHandler(syncHandlerId, syncHandlerObj); } }); } /** * @typedef {Object} OpenSettingsOptions * @param {Boolean} showDefaultKey (default: false) */ /** * Open the extension settings in a new browser tab * @param {OpenSettingsOptions} [options] * @returns {Promise.&lt;undefined, Error&gt;} */ openSettings(options) { return send('open-settings', {identifier: this.identifier, options}); } } /** * Not accessible, instance can be obtained using {@link Keyring#createKeyBackupContainer} * @param {String} popupId */ class KeyBackupPopup { constructor(popupId) { this.popupId = popupId; } /** * @returns {Promise.&lt;undefined, Error&gt;} - key backup ready or error * @throws {Error} */ isReady() { return send('keybackup-popup-isready', {popupId: this.popupId}); } } /** * Not accessible, instance can be obtained using {@link Keyring#createKeyGenContainer}. * @param {String} generatorId - the internal id of the generator */ class Generator { constructor(generatorId) { this.generatorId = generatorId; } /** * Generate a private key * @param {Promise.&lt;undefined, Error&gt;} [confirm] - newly generate key is only persisted if Promise resolves, * in the reject or timeout case the generated key is rejected * @returns {Promise.&lt;AsciiArmored, Error&gt;} - the newly generated key (public part) * @throws {Error} */ generate(confirm) { return send('generator-generate', {generatorId: this.generatorId, confirmRequired: Boolean(confirm)}).then(armored =&gt; { if (confirm) { confirm.then(() =&gt; { emit('generator-generate-confirm', {generatorId: this.generatorId}); }).catch(e =&gt; { emit('generator-generate-reject', {generatorId: this.generatorId, error: objError(e)}); }); } return armored; }); } } /** * Not accessible, instance can be obtained using {@link Keyring#restoreBackupContainer}. * @param {String} restoreId - the internal id of the restore backup */ class RestoreBackup { constructor(restoreId) { this.restoreId = restoreId; } /** * @returns {Promise.&lt;undefined, Error&gt;} - key restore ready or error * @throws {Error} */ isReady() { return send('restore-backup-isready', {restoreId: this.restoreId}); } } /** * Not accessible, instance can be obtained using {@link Mailvelope#createEditorContainer}. * @param {String} editorId - the internal id of the editor */ class Editor { constructor(editorId) { this.editorId = editorId; } /** * Requests the encryption of the editor content for the given recipients. * @param {Array.&lt;String&gt;} recipients - list of email addresses for public key lookup and encryption * @returns {Promise.&lt;AsciiArmored, Error&gt;} * @throws {Error} error.code = 'ENCRYPT_IN_PROGRESS' &lt;br&gt; * error.code = 'NO_KEY_FOR_RECIPIENT' &lt;br&gt; * error.code = 'ENCRYPT_QUOTA_SIZE' * @example * editor.encrypt(['abc@web.de', 'info@com']).then(function (armoredMessage) { * console.log('encrypt', armoredMessage); // prints: \"-----BEGIN PGP MESSAGE...\" * } */ encrypt(recipients) { return send('editor-encrypt', {recipients, editorId: this.editorId}); } /** * Encrypt and sign the content of the editor with the default key of the user. * To be used to save drafts. To restore drafts use the options.armoredDraft parameter of the createEditorContainer method. * @returns {Promise.&lt;AsciiArmored, Error&gt;} * @throws {Error} error.code = 'ENCRYPT_IN_PROGRESS' &lt;br&gt; * error.code = 'NO_KEY_FOR_ENCRYPTION' &lt;br&gt; * error.code = 'ENCRYPT_QUOTA_SIZE' */ createDraft() { return send('editor-create-draft', {editorId: this.editorId}); } } const callbacks = Object.create(null); class SyncHandler { constructor(syncHandlerId, handlers) { this.syncHandlerId = syncHandlerId; this.handlers = handlers; } update(handlers) { for (const handle in handlers) { this.handlers[handle] = handlers[handle]; } } } function handleSyncEvent({type, id, data}) { let handler = null; switch (type) { case 'upload': handler = syncHandler.handlers.uploadSync; break; case 'download': handler = syncHandler.handlers.downloadSync; break; case 'backup': handler = syncHandler.handlers.backup; break; case 'restore': handler = syncHandler.handlers.restore; break; default: console.log('mailvelope-client-api unknown sync event', type); } if (!handler) { emit('sync-handler-done', {syncHandlerId: syncHandler.syncHandlerId, syncType: type, error: {message: 'Sync handler not available'}, id}); return; } handler(data) .then(result =&gt; { emit('sync-handler-done', {syncHandlerId: syncHandler.syncHandlerId, syncType: type, syncData: result, id}); }) .catch(error =&gt; { if (!error) { error = new Error('Unknown Error'); } emit('sync-handler-done', {syncHandlerId: syncHandler.syncHandlerId, syncType: type, error: objError(error), id}); }); } function eventListener(msg) { if (msg.origin !== window.location.origin || msg.data.mvelo_client || !msg.data.mvelo_extension) { return; } //console.log('clientAPI eventListener', event.data); switch (msg.data.event) { case 'sync-event': handleSyncEvent(msg.data); break; case '_reply': { let error; if (msg.data.error) { error = mapError(msg.data.error); if (!callbacks[msg.data._reply]) { throw error; } } callbacks[msg.data._reply](error, msg.data.result); delete callbacks[msg.data._reply]; break; } default: console.log('mailvelope-client-api unknown event', msg.data.event); } } function disconnectListener() { window.removeEventListener('message', eventListener); connected = false; } function getHash() { let result = ''; const buf = new Uint16Array(6); window.crypto.getRandomValues(buf); for (let i = 0; i &lt; buf.length; i++) { result += buf[i].toString(16); } return result; } function mapError(obj) { const error = new Error(obj.message); error.code = obj.code; return error; } function objError(error) { if (error instanceof Error || typeof error === 'string') { error = {message: error.message || String(error)}; } return error; } function checkConnection() { if (!connected) { const error = new Error('Connection to Mailvelope extension is no longer alive.'); error.code = 'NO_CONNECTION'; throw error; } } function emit(event, data) { checkConnection(); const message = {...data, event, mvelo_client: true}; window.postMessage(message, window.location.origin); } function send(event, data) { checkConnection(); return new Promise((resolve, reject) =&gt; { const message = {...data, event, mvelo_client: true, _reply: getHash()}; callbacks[message._reply] = (err, data) =&gt; err ? reject(err) : resolve(data); window.postMessage(message, window.location.origin); }); } export function init() { window.mailvelope = new Mailvelope(); window.addEventListener('message', eventListener); window.addEventListener('mailvelope-disconnect', disconnectListener); window.setTimeout(() =&gt; { window.dispatchEvent(new CustomEvent('mailvelope', {detail: window.mailvelope})); }, 1); } × Search results Close "},"web-components.js.html":{"id":"web-components.js.html","title":"Source: web-components.js","body":" Mailvelope API Classes EditorGeneratorKeyBackupPopupKeyringMailvelopeOpenPGPEncryptedFormRestoreBackup Tutorials Readme Global Global Source: web-components.js /** * The MIT License (MIT) * * Copyright (c) 2018-2019 Mailvelope GmbH * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. */ /** * OpenPGPEncryptedForm custom HTMLElement */ class OpenPGPEncryptedForm extends HTMLElement { // Invoked when the custom element is first connected to the document's DOM. connectedCallback() { this.dispatchEvent(new Event('connected')); const id = this.getAttribute('id'); if (!id) { const error = new Error('No form id for openpgp-encrypted-tag. Please add a unique identifier.'); error.code = 'NO_FORM_ID'; return this.onError(error); } let html; const scriptTags = this.getElementsByTagName('script'); if (scriptTags.length) { html = scriptTags[0].innerText; } else { const error = new Error('No form template for openpgp-encrypted-tag. Please add a form template.'); error.code = 'NO_FORM_SCRIPT'; return this.onError(error); } window.mailvelope.createEncryptedFormContainer(`#${id}`, html, this.getAttribute('signature')) .then(data =&gt; this.onEncrypt(data), error =&gt; this.onError(error)); } onEncrypt(data) { this.dispatchEvent(new CustomEvent('encrypt', { detail: {armoredData: data.armoredData}, bubbles: true, cancelable: true })); } onError(error) { this.dispatchEvent(new ErrorEvent('error', { message: error.message, error })); } } class OpenPGPEmailRead extends HTMLElement { connectedCallback() { const id = this.getAttribute('id'); if (!id) { return this.onError(new Error('Missing id attribute on openpgp-email-read tag. Please add a unique identifier.')); } const [armoredElement] = this.getElementsByClassName('armored'); const armored = armoredElement ? armoredElement.textContent : this.dataset.armored; if (!armored) { return this.onError(new Error('Armored message required as &lt;template class=\"armored\"&gt; child element or data-armored attribute.')); } const options = {senderAddress: this.dataset.senderAddress}; if (window.mailvelope) { this.createContainer(id, armored, options); } else { window.addEventListener('mailvelope', () =&gt; this.createContainer(id, armored, options), {once: true}); } } async createContainer(id, armored, options) { try { const {error} = await window.mailvelope.createDisplayContainer(`#${id}`, armored, null, options); if (error) { return this.onError(error); } this.onReady(); } catch (e) { this.onError(e); } } onReady() { this.dispatchEvent(new CustomEvent('ready', {bubbles: true, cancelable: true})); } onError(error) { this.dispatchEvent(new ErrorEvent('error', {message: error.message, error})); } } class OpenPGPEmailWrite extends HTMLElement { connectedCallback() { const id = this.getAttribute('id'); if (!id) { return this.onError(new Error('Missing id attribute on openpgp-email-write tag. Please add a unique identifier.')); } const [armoredDraftElement] = this.getElementsByClassName('armored-draft'); const armoredDraft = armoredDraftElement ? armoredDraftElement.textContent : undefined; const [quotedMailElement] = this.getElementsByClassName('quoted-mail'); const quotedMail = quotedMailElement ? quotedMailElement.textContent : undefined; let {quota, signMsg, keepAttachments} = this.dataset; quota = quota ? Number(quota) : undefined; signMsg = signMsg || signMsg === '' ? true : false; keepAttachments = keepAttachments || keepAttachments === '' ? true : false; const options = {armoredDraft, quotedMail, ...this.dataset, quota, signMsg, keepAttachments}; if (window.mailvelope) { this.createEditor(id, options); } else { window.addEventListener('mailvelope', () =&gt; this.createEditor(id, options), {once: true}); } } async createEditor(id, options) { try { this.editor = await window.mailvelope.createEditorContainer(`#${id}`, null, options); this.onReady(this.editor); } catch (e) { this.onError(e); } } onReady(editor) { this.dispatchEvent(new CustomEvent('ready', {bubbles: true, cancelable: true, detail: {editor}})); } onError(error) { this.dispatchEvent(new ErrorEvent('error', {message: error.message, error})); } } export function init() { // See. https://developer.mozilla.org/en-US/docs/Web/API/Window/customElements#Specification#Browser_compatibility if (!window.customElements) { return; } window.customElements.define('openpgp-encrypted-form', OpenPGPEncryptedForm); window.customElements.define('openpgp-email-read', OpenPGPEmailRead); window.customElements.define('openpgp-email-write', OpenPGPEmailWrite); } × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" Mailvelope API Classes EditorGeneratorKeyBackupPopupKeyringMailvelopeOpenPGPEncryptedFormRestoreBackup Tutorials Readme Global Global Global Type Definitions additionalMailHeaders Type: Object Properties: Name Type Description autocrypt String the Autocrypt header that should be added to the outgoing mail Source: client-api.js, line 284 AsciiArmored Ascii Armored PGP Text Block Type: String Source: client-api.js, line 62 AutocryptMailHeaders Type: Object Properties: Name Type Description autocrypt String the Autocrypt header to process from String the From header date String the Date header Source: client-api.js, line 326 BackupSyncHandler() Parameters: Type Description BackupSyncPacket object with backup data Source: client-api.js, line 464 Returns: Type Promise.&lt;undefined, Error&gt; BackupSyncPacket Type: Object Properties: Name Type Description backup AsciiArmored encrypted key backup as PGP armored message Source: client-api.js, line 459 CssSelector CSS Selector String Type: String Source: client-api.js, line 67 DisplayContainer Type: Object Properties: Name Type Description error Error Error object with code and message attribute error.code = 'DECRYPT_ERROR' - generic decrypt error error.code = 'ARMOR_PARSE_ERROR' - error while parsing the armored message error.code = 'PWD_DIALOG_CANCEL' - user canceled password dialog error.code = 'NO_KEY_FOUND' - no private key found to decrypt this message Source: client-api.js, line 77 DisplayContainerOptions Type: Object Properties: Name Type Description senderAddress String email address of sender, used to indentify key for signature verification Source: client-api.js, line 72 DownloadSyncHandler(downloadObj) Parameters: Name Type Description downloadObj Object meta info for download Properties Name Type Description eTag String entity tag for the current local keyring, or null if no local eTag Source: client-api.js, line 451 Returns: if version on server has same eTag, then keyringMsg property of reply is empty, but eTag in reply has to be set if server is initial and downloadObj.eTag is not null, then the promise is resolved with empty eTag Type Promise.&lt;DownloadSyncReply, Error&gt; DownloadSyncReply Type: Object Properties: Name Type Description keyringMsg AsciiArmored encrypted keyring as PGP armored message, or null if no newer version available eTag String entity tag for the current encrypted keyring message, or null if server is intial Source: client-api.js, line 445 EditorContainerOptions Type: Object Properties: Name Type Description quota number mail content (text + attachments) limit in kilobytes (default: 20480) signMsg boolean if true then the mail will be signed (default: false) armoredDraft AsciiArmored a PGP message, signed and encrypted with the default key of the user, will be used to restore a draft in the editor The armoredDraft parameter can't be combined with the parameters: predefinedText, quotedMail... parameters, keepAttachments predefinedText String text that will be added to the editor quotedMail AsciiArmored mail that should be quoted quotedMailIndent boolean if true the quoted mail will be indented (default: true) quotedMailHeader String header to be added before the quoted mail keepAttachments boolean add attachments of quotedMail to editor (default: false) Source: client-api.js, line 109 KeyBackupContainerOptions Type: Object Source: client-api.js, line 390 KeyGenContainerOptions Type: Object Properties: Name Type Description userIds Array.&lt;UserId&gt; array of user IDs. The first entry in the array is set as the primary user ID. keySize number key size in bit, optional, default: 2048, valid values: 2048, 4096. Source: client-api.js, line 372 LookupResult Type: Object Properties: Name Type Argument Description fingerprint String Fingerprint of the key lastModified Date last time the key was modified source String Source the key was found at Currently available: * 'LOC' - local key ring * 'WKD' - web key directory * 'MKS' - mailvelope key server * 'AC' - autocrypt lastSeen Date &lt;optional&gt; last time the key was seen (not set for local keys) armored String &lt;optional&gt; Armored key that can be imported (not set for local keys) Source: client-api.js, line 214 OpenSettingsOptions Type: Object Source: client-api.js, line 501 outgoingMailHeaders Type: Object Properties: Name Type Description from String the From header Source: client-api.js, line 290 PrivateKeyContainerOptions Type: Object Properties: Name Type Description restorePassword boolean (default: false) Source: client-api.js, line 405 RestoreSyncHandler() Source: client-api.js, line 470 Returns: Type Promise.&lt;BackupSyncPacket, Error&gt; SettingsContainerOptions Type: Object Properties: Name Type Description email String the email address of the current user fullName String the full name of the current user Source: client-api.js, line 151 SyncHandlerObject Type: Object Properties: Name Type Description uploadSync UploadSyncHandler function called by Mailvelope to upload the keyring (public keys), the message is encrypted with the default private key downloadSync DownloadSyncHandler function called by Mailvelope to download the encrypted keyring (public keys) backup BackupSyncHandler function called by Mailvelope to upload a symmetrically encrypted private key backup restore RestoreSyncHandler function called by Mailvelope to restore a private key backup Source: client-api.js, line 475 UploadSyncHandler(uploadObj) Parameters: Name Type Description uploadObj Object object with upload data Properties Name Type Description eTag String entity tag for the uploaded encrypted keyring, or null if initial upload keyringMsg AsciiArmored encrypted keyring as PGP armored message Source: client-api.js, line 436 Returns: if version on server has different eTag, then the promise is rejected if server is initial and uploadObj.eTag is not null, then the promise is rejected Type Promise.&lt;UploadSyncReply, Error&gt; UploadSyncReply Type: Object Properties: Name Type Description eTag String entity tag for the uploaded encrypted keyring Source: client-api.js, line 431 UserId Type: Object Properties: Name Type Description email String the email address of the current user fullName String the full name of the current user Source: client-api.js, line 366 × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Mailvelope API Classes EditorGeneratorKeyBackupPopupKeyringMailvelopeOpenPGPEncryptedFormRestoreBackup Tutorials Readme Global Global Classes Classes Editor Generator KeyBackupPopup Keyring Mailvelope OpenPGPEncryptedForm RestoreBackup × Search results Close "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" Mailvelope API Classes EditorGeneratorKeyBackupPopupKeyringMailvelopeOpenPGPEncryptedFormRestoreBackup Tutorials Readme Global Global Tutorials Classes Editor Generator KeyBackupPopup Keyring Mailvelope OpenPGPEncryptedForm RestoreBackup × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Mailvelope API Classes EditorGeneratorKeyBackupPopupKeyringMailvelopeOpenPGPEncryptedFormRestoreBackup Tutorials Readme Global Global Basic Usage The Mailvelope extension injects a script into the page to make its client-api accessible. The window.mailvelope object will be an instance of the Mailvelope class, please refer to its methods for further documentation. Events mailvelope The event will be triggered once the window.mailvelope object is available. Since the timing is not defined consumers will have to use the following method or something equivalent to reliably obtain a reference to the Mailvelope client-API. (function() { function init() { if (typeof mailvelope !== 'undefined') { mailvelopeLoaded(); } else { window.addEventListener('mailvelope', mailvelopeLoaded, false); } } function mailvelopeLoaded() { // window.mailvelope object is available } $(document).ready(init); }()); mailvelope-disconnect The event is fired during an update of the extension. The auto-update mechanism of the browser can initiate the update at any time. Existing Mailvelope containers on a consumer page are no longer functional after the update. The disconnect event can be used to inform users about potential data loss (only relevant for Mailvelope editor) and trigger a page reload. window.addEventListener('mailvelope-disconnect', function(event) { // event.detail.version is the version of the updated extension }, false); Promises The client-API uses the new ECMAScript 6 Promises. At the moment JSDoc does not have specialized support for this new language feature, although adding support is in discussion. Due to this reason we will use the @throws tag to document errors that should be expected in the rejection of a promise and will not actually be thrown by the function returning the promise. × Search results Close "},"Editor.html":{"id":"Editor.html","title":"Class: Editor","body":" Mailvelope API Classes EditorGeneratorKeyBackupPopupKeyringMailvelopeOpenPGPEncryptedFormRestoreBackup Tutorials Readme Global Global Class: Editor Editor Not accessible, instance can be obtained using Mailvelope#createEditorContainer. new Editor(editorId) Parameters: Name Type Description editorId String the internal id of the editor Source: client-api.js, line 587 Methods createDraft() Encrypt and sign the content of the editor with the default key of the user. To be used to save drafts. To restore drafts use the options.armoredDraft parameter of the createEditorContainer method. Source: client-api.js, line 615 Throws: error.code = 'ENCRYPT_IN_PROGRESS' error.code = 'NO_KEY_FOR_ENCRYPTION' error.code = 'ENCRYPT_QUOTA_SIZE' Type Error Returns: Type Promise.&lt;AsciiArmored, Error&gt; encrypt(recipients) Requests the encryption of the editor content for the given recipients. Parameters: Name Type Description recipients Array.&lt;String&gt; list of email addresses for public key lookup and encryption Source: client-api.js, line 603 Throws: error.code = 'ENCRYPT_IN_PROGRESS' error.code = 'NO_KEY_FOR_RECIPIENT' error.code = 'ENCRYPT_QUOTA_SIZE' Type Error Returns: Type Promise.&lt;AsciiArmored, Error&gt; Example editor.encrypt(['abc@web.de', 'info@com']).then(function (armoredMessage) { console.log('encrypt', armoredMessage); // prints: \"-----BEGIN PGP MESSAGE...\" } × Search results Close "},"Generator.html":{"id":"Generator.html","title":"Class: Generator","body":" Mailvelope API Classes EditorGeneratorKeyBackupPopupKeyringMailvelopeOpenPGPEncryptedFormRestoreBackup Tutorials Readme Global Global Class: Generator Generator Not accessible, instance can be obtained using Keyring#createKeyGenContainer. new Generator(generatorId) Parameters: Name Type Description generatorId String the internal id of the generator Source: client-api.js, line 539 Methods generate( [confirm]) Generate a private key Parameters: Name Type Argument Description confirm Promise.&lt;undefined, Error&gt; &lt;optional&gt; newly generate key is only persisted if Promise resolves, in the reject or timeout case the generated key is rejected Source: client-api.js, line 550 Throws: Error Returns: the newly generated key (public part) Type Promise.&lt;AsciiArmored, Error&gt; × Search results Close "},"KeyBackupPopup.html":{"id":"KeyBackupPopup.html","title":"Class: KeyBackupPopup","body":" Mailvelope API Classes EditorGeneratorKeyBackupPopupKeyringMailvelopeOpenPGPEncryptedFormRestoreBackup Tutorials Readme Global Global Class: KeyBackupPopup KeyBackupPopup Not accessible, instance can be obtained using Keyring#createKeyBackupContainer new KeyBackupPopup(popupId) Parameters: Name Type Description popupId String Source: client-api.js, line 521 Methods isReady() Source: client-api.js, line 529 Throws: Error Returns: key backup ready or error Type Promise.&lt;undefined, Error&gt; × Search results Close "},"Keyring.html":{"id":"Keyring.html","title":"Class: Keyring","body":" Mailvelope API Classes EditorGeneratorKeyBackupPopupKeyringMailvelopeOpenPGPEncryptedFormRestoreBackup Tutorials Readme Global Global Class: Keyring Keyring Not accessible, instance can be obtained using Mailvelope#getKeyring or Mailvelope#createKeyring. new Keyring(identifier, options) Parameters: Name Type Description identifier String the keyring identifier options object the options Properties: Name Type Description logoRev number revision number of the keyring logo, initial value: 0 Source: client-api.js, line 209 Methods additionalHeadersForOutgoingEmail(headers) Returns headers that should be added to an outgoing email. So far this is only the autocrypt header. Parameters: Name Type Description headers outgoingMailHeaders headers of the outgoing mail. In particular from to select the key Source: client-api.js, line 308 Throws: error.code = 'NO_KEY_FOR_ADDRESS' Type Error Returns: Type Promise.&lt;additionalMailHeaders, Error&gt; Example keyring.additionalHeadersForOutgoingEmail(from: 'abc@web.de').then(function(additional) { console.log('additionalHeadersForOutgoingEmail', additional); // logs: {autocrypt: \"addr=abc@web.de; prefer-encrypt=mutual; keydata=...\"} }); addSyncHandler(syncHandlerObj) Add various functions for keyring synchronization Parameters: Name Type Description syncHandlerObj SyncHandlerObject Source: client-api.js, line 488 Returns: Type Promise.&lt;undefined, Error&gt; createKeyBackupContainer(selector, options) Creates an iframe to initiate the key backup process. Parameters: Name Type Description selector CssSelector target container options KeyBackupContainerOptions Source: client-api.js, line 401 Returns: Type Promise.&lt;KeyBackupPopup, Error&gt; createKeyGenContainer(selector, options) Creates an iframe to display the key generation container. The iframe will be injected into the container identified by selector. Parameters: Name Type Description selector CssSelector target container options KeyGenContainerOptions Source: client-api.js, line 386 Throws: error.code = 'INPUT_NOT_VALID' Type Error Returns: Type Promise.&lt;Generator, Error&gt; exportOwnPublicKey(emailAddr) Exports the public key as an ascii armored string. Only keys belonging to the user (corresponding private key exists) can be exported. Parameters: Name Type Description emailAddr String email address to identify the public+private key Source: client-api.js, line 280 Throws: error.code = 'NO_KEY_FOR_ADDRESS' Type Error Returns: Type Promise.&lt;AsciiArmored, Error&gt; Example keyring.exportOwnPublicKey('abc@web.de').then(function(armoredPublicKey) { console.log('exportOwnPublicKey', armoredPublicKey); // prints: \"-----BEGIN PGP PUBLIC KEY BLOCK...\" }); hasPrivateKey(fingerprint) Check if keyring contains valid private key with given fingerprint Parameters: Name Type Description fingerprint String | Object or Object with fingerprint or email property Source: client-api.js, line 425 Returns: Type Promise.&lt;boolean, Error&gt; importPublicKey(armored) Asks the user if they want to import the public key. Parameters: Name Type Description armored AsciiArmored public key to import Source: client-api.js, line 322 Throws: error.code = 'IMPORT_ERROR' error.code = 'WRONG_ARMORED_TYPE' Type Error Returns: 'IMPORTED' - key has been imported 'UPDATED' - key already in keyring, new key merged with existing key 'INVALIDATED' - key has been updated, new status of key is 'invalid' (e.g. revoked) 'REJECTED' - key import rejected by user Type Promise.&lt;String, Error&gt; openSettings( [options]) Open the extension settings in a new browser tab Parameters: Name Type Argument Description options OpenSettingsOptions &lt;optional&gt; Source: client-api.js, line 511 Returns: Type Promise.&lt;undefined, Error&gt; processAutocryptHeader(headers) Process Autocrypt header from message being read. Parameters: Name Type Description headers AutocryptMailHeaders the relevant mail headers Source: client-api.js, line 340 Throws: error.code = 'INVALID_HEADER' error.code = 'STORAGE_ERROR' Type Error Returns: Type Promise.&lt;undefined, Error&gt; restoreBackupContainer(selector, options) Creates an iframe to restore the backup. Parameters: Name Type Description selector CssSelector target container options PrivateKeyContainerOptions Source: client-api.js, line 416 Returns: Type Promise.&lt;undefined, Error&gt; setLogo(dataURL, revision) Set logo for keyring. The image is persisted in Mailvelope with a revision number, therefore the method is only required after new keyring generation or if logo and revision number changes. Parameters: Name Type Description dataURL String data-URL representing the logo, max. file size: ~10KB, max. image size: 192x96px, content-type: image/png revision number revision number Source: client-api.js, line 360 Throws: error.code = 'LOGO_INVALID' error.code = 'REVISION_INVALID' Type Error Returns: Type Promise.&lt;undefined, Error&gt; Example keyring.setLogo('data:image/png;base64,iVBORS==', 3).then(function() { // keyring.logoRev == 3 }).catch(function(error) { // logo update failed }); validKeyForAddress(recipients) Checks for valid key in the keyring for provided email addresses If none is found also checks in other sources (see LookupResult). Parameters: Name Type Description recipients Array list of email addresses for key lookup Source: client-api.js, line 255 Returns: The object maps email addresses to: false: no valid key {keys: [LookupResult]}: valid keys Type Promise.&lt;Object, Error&gt; Example keyring.validKeyForAddress(['abc@web.de', 'info@mailvelope.com']).then(function(result) { console.log(result); // { // 'abc@web.de': false, // 'info@mailvelope.com': { // keys: [ // { // fingerprint: 'f37377c39898d05ffd39157a98bbec557ce08def', // lastModified: Tue May 19 2015 10:36:53 GMT+0200 (CEST), // source: 'LOC' // } // ] // } // } }); × Search results Close "},"Mailvelope.html":{"id":"Mailvelope.html","title":"Class: Mailvelope","body":" Mailvelope API Classes EditorGeneratorKeyBackupPopupKeyringMailvelopeOpenPGPEncryptedFormRestoreBackup Tutorials Readme Global Global Class: Mailvelope Mailvelope new Mailvelope() Source: client-api.js, line 28 Methods createDisplayContainer(selector, armored [, keyring], options) Creates an iframe to display the decrypted content of the encrypted mail. The iframe will be injected into the container identified by selector. Parameters: Name Type Argument Description selector CssSelector target container armored AsciiArmored the encrypted mail to display keyring Keyring &lt;optional&gt; the keyring to use for this operation options DisplayContainerOptions Source: client-api.js, line 95 Returns: Type Promise.&lt;DisplayContainer, Error&gt; createEditorContainer(selector [, keyring], options) Creates an iframe with an editor for a new encrypted mail. The iframe will be injected into the container identified by selector. Parameters: Name Type Argument Description selector CssSelector target container keyring Keyring &lt;optional&gt; the keyring to use for this operation options EditorContainerOptions Source: client-api.js, line 142 Throws: error.code = 'WRONG_ARMORED_TYPE' - parameters of type AsciiArmored do not have the correct armor type error.code = 'INVALID_OPTIONS' - invalid combination of options parameter Type Error Returns: Type Promise.&lt;Editor, Error&gt; Example mailvelope.createEditorContainer('#editor-element', keyring).then(function(editor) { // register event handler for mail client send button $('#mailer-send').click(function() { // encrypt current content of editor for array of recipients editor.encrypt(['info@mailvelope.com', 'abc@web.de']).then(function(armored) { console.log('encrypted message', armored); }); }); }); createEncryptedFormContainer(@param, @param, @param) Creates an iframe to display an encrypted form The iframe will be injected into the container identified by selector. Parameters: Name Type Description @param String selector - the id of target container @param String formHtml - the form definition @param String signature - the OpenPGP signature Source: client-api.js, line 183 Throws: error.code = 'INVALID_FORM' the form definition is not valid Type Error Returns: an object that includes armoredData Type Promise.&lt;Object, Error&gt; createKeyring(identifier) Creates a Keyring for the given identifier Parameters: Name Type Description identifier String the identifier of the new keyring Source: client-api.js, line 58 Throws: error.code = 'KEYRING_ALREADY_EXISTS' Type Error Returns: Type Promise.&lt;Keyring, Error&gt; Example mailvelope.createKeyring('Account-ID-4711').then(function(keyring) { // continue to display the settings container and start the setup wizard mailvelope.createSettingsContainer('#mailvelope-settings', keyring); }); createSettingsContainer(selector [, keyring], options) Creates an iframe to display the keyring settings. The iframe will be injected into the container identified by selector. Parameters: Name Type Argument Description selector CssSelector target container keyring Keyring &lt;optional&gt; the keyring to use for the setup options SettingsContainerOptions Source: client-api.js, line 165 Returns: Type Promise.&lt;undefined, Error&gt; getKeyring(identifier) Retrieves the Keyring for the given identifier Parameters: Name Type Description identifier String the identifier of the keyring, if empty the main keyring is returned Source: client-api.js, line 43 Throws: error.code = 'NO_KEYRING_FOR_ID' Type Error Returns: Type Promise.&lt;Keyring, Error&gt; getVersion() Gives access to the mailvelope extension version Source: client-api.js, line 33 Returns: Type Promise.&lt;String, Error&gt; × Search results Close "},"OpenPGPEncryptedForm.html":{"id":"OpenPGPEncryptedForm.html","title":"Class: OpenPGPEncryptedForm","body":" Mailvelope API Classes EditorGeneratorKeyBackupPopupKeyringMailvelopeOpenPGPEncryptedFormRestoreBackup Tutorials Readme Global Global Class: OpenPGPEncryptedForm OpenPGPEncryptedForm OpenPGPEncryptedForm custom HTMLElement new OpenPGPEncryptedForm() Source: web-components.js, line 28 × Search results Close "},"RestoreBackup.html":{"id":"RestoreBackup.html","title":"Class: RestoreBackup","body":" Mailvelope API Classes EditorGeneratorKeyBackupPopupKeyringMailvelopeOpenPGPEncryptedFormRestoreBackup Tutorials Readme Global Global Class: RestoreBackup RestoreBackup Not accessible, instance can be obtained using Keyring#restoreBackupContainer. new RestoreBackup(restoreId) Parameters: Name Type Description restoreId String the internal id of the restore backup Source: client-api.js, line 569 Methods isReady() Source: client-api.js, line 577 Throws: Error Returns: key restore ready or error Type Promise.&lt;undefined, Error&gt; × Search results Close "},"tutorial-Readme.html":{"id":"tutorial-Readme.html","title":"Tutorial: Readme","body":" Mailvelope API Classes EditorGeneratorKeyBackupPopupKeyringMailvelopeOpenPGPEncryptedFormRestoreBackup Tutorials Readme Global Global Readme Basic Usage The Mailvelope extension injects a script into the page to make its client-api accessible. The window.mailvelope object will be an instance of the Mailvelope class, please refer to its methods for further documentation. Events mailvelope The event will be triggered once the window.mailvelope object is available. Since the timing is not defined consumers will have to use the following method or something equivalent to reliably obtain a reference to the Mailvelope client-API. (function() { function init() { if (typeof mailvelope !== 'undefined') { mailvelopeLoaded(); } else { window.addEventListener('mailvelope', mailvelopeLoaded, false); } } function mailvelopeLoaded() { // window.mailvelope object is available } $(document).ready(init); }()); mailvelope-disconnect The event is fired during an update of the extension. The auto-update mechanism of the browser can initiate the update at any time. Existing Mailvelope containers on a consumer page are no longer functional after the update. The disconnect event can be used to inform users about potential data loss (only relevant for Mailvelope editor) and trigger a page reload. window.addEventListener('mailvelope-disconnect', function(event) { // event.detail.version is the version of the updated extension }, false); Promises The client-API uses the new ECMAScript 6 Promises. At the moment JSDoc does not have specialized support for this new language feature, although adding support is in discussion. Due to this reason we will use the @throws tag to document errors that should be expected in the rejection of a promise and will not actually be thrown by the function returning the promise. × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
